
<html>


<h1>Test of QMLReport<br>Tool to generate PDF file from QML</h1>
$val1$ and $val2$ provide an easy way to rapidly develop customized,
reusable components entirely within $val2$. As these components grow in complexity, performance and maintainability
often suffer, a drawback that is especially noticeable on low-powered embedded and mobile devices.
In addition, some specialized components simply cannot be implemented by combining existing $val1$ items in $val2$.
For these cases, $val1$ provides access to its underlying OpenGL scene graph via a C++ API.
Components created this way are more closely aligned to the underlying scene graph architecture allowing
improved performance and a cleaner implementation.
<br><br>
$val1$ provides a flexible and easy-to-use framework for developing a wide range of applications from
automotive HMIs to interactive desktop applications. Under the hood, it uses an OpenGL scene graph for rendering,
allowing advanced effects and fluid animations even on low-powered  systems. Complex components written entirely in
$val2$ can cause noticeable performance problems especially on these low-powered systems. $val1$ provides a C++ API
to directly access its underlying scene graph for creating optimized components with better encapsulation.
These components can then be reused from $val2$ in the same way as the built-in $val1$ items.
<br><br>
The focus of this talk will be describing the steps necessary to create a $val1$ component using C++ and OpenGL.
We will start with a custom component written entirely in $val2$ and point out the performance and maintenance problems
with this approach. We will then reimplement this component in C++ and OpenGL, step-by-step, so that by the end you’ll
know enough to create your own C++ $val1$ components. Finally we’ll compare the resulting component’s implementation
and performance against the original to see the improvement. I will also briefly mention the QtQuickFrameBufferObject as
an alternative and discuss when you would use it instead of the scene graph API.
<br><br>
The talk is aimed at developers with minimal OpenGL experience. It will briefly introduce enough of the basic OpenGL
concepts to get you started writing a custom $val1$ item.<br><br><br>


<div style='font-size:20px'>KD Reports creates all kinds of reports from within Qt applications.</div>
<br><br>
KD Reports generates printable and exportable reports from code and from XML descriptions.
Reports may contain text paragraphs, tables, headlines, charts, headers and footers, and more.
<br><br>
Creating Reports out of Qt Applications Reporting is a very common task in almost all applications.
From the visualization of database contents in printouts to the creation of invoices or ID cards,
it is all about formatting information for printing.
<br><br>
KD Reports is a developer tool used in source code, but it allows using templates that are created by design staff.
This way, updating reports does not necessarily require code changes.  KD Reports is able to retrieve data for reports
from databases.  Also, it interfaces to Qt’s Model-View technology to access existing application model data.
<br><br>
A report often spans multiple pages, or elements of it need to be placed at specific locations to be printed in forms.
KD Reports provides page-breaking and endless paper support.  It also supports exact measurements for the placement of
elements in form cells.  Tables that span multiple pages can have repeating header rows assigned.
Those rows will be printed on top of every page the tables spans.
<br><br>
Watermarks can be used to add company logos or classification marks to documents.
They appear behind the report contents on every page.  Headers and footers can contain images or other elements.

The created reports can be shown in a preview dialog that is part of KD Reports.
They can be saved to PDF files or sent directly to a printer.
<br><br>
<div style='font-size:20px'>Creating a Report</div><br><br>

Creating a report always starts with creating a KDReports::Report object.  Then, there are two basic modes of operation:
<ul>
    <li>Elements like text blocks and images are created programmatically.
        The created elements form sequences that are either inlined or stacked as block (similar to HTML formatting rules).</li>
    <li>The report is initialized from an XML template. Then, the programmer fills in parts like table cell contents.
        In this mode, the programmer is less concerned with the actual formatting.  External designers or marketing and sales
        staff can be tasked with creating the report structure.</li>
</ul>

<div style='font-size:20px'>Elements of a Report</div>
<br><br>
Reports may contain any number of supported elements.  Developers can also add their own custom element types.
Element types that are shipped with KD Reports include:
<ul>
    <li>Images: Images can be loaded from external sources or created using Qt’s painting classes.
        All image formats supported by Qt or external image format plug-ins can be used.
    </li>
    <li>Text Paragraphs: Text can be inlined or block formatted.  Text paragraphs support all usual style
        options that developers expect (left, right, justified, or centered formatting) and all possible font style attributes.
        Text blocks can be nested to allow a part of a paragraph to have highlighted formatting, for example.
    </li>
    <li>Tables: Tables can be created from multiple sources of data (programmatically, from Model-View models,
        and from SQL databases).  Table cells can be individually formatted.  Cells can contain other elements,
        such as images.
    </li>
    <li>Charts: Charts are integrated if KDAB’s KD Chart package is available.  If integrated, charts can be used anywhere
        images could be.  Since KD Chart uses Model-View as well, creating chart elements that visualize
        table contents is easy.
    </li>
    <li>Preview Dialog: KD Reports ships with a preview dialog that can be used to give end users options on how to
        store or print the created reports.
    </li>
</ul>
</html>
